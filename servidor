#!/usr/bin/env python3
import asyncio
from tcp import Servidor
from tcp import Conexao
import re

# Define o atributo global dados_residuais para a classe Conexao
Conexao.dados_residuais = b''

# Define o atributo global nicks para a classe Conexao
Conexao.nicks = {}

# Define o atributo global canais para a classe Conexao
Conexao.canais = {}

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    # Concatena os dados residuais com os dados
    dados = Conexao.dados_residuais + dados
    
    # Cria uma lista para armazenar linhas terminadas em b'\r\n'
    linhas = dados.split(b'\r\n')

    # Se o último elemento da lista terminar com b'\r\n'
    if linhas[-1].endswith(b'\r\n'):
        # Caso não tenha dados residuais
        Conexao.dados_residuais = b''
    else:
        # Caso tenha dados residuais atribuí-lo a variável e removê-lo da lista
        Conexao.dados_residuais = linhas.pop(-1)

    for linha in linhas:
        print(conexao, linha)
        processar_linha(conexao, linha)
    
def processar_linha(conexao, linha):
    # Remove espaços do começo e do final da string
    linha = linha.strip()
        
    ''' Verifica se as primeiras letras da linha é um comando
    indiferente de maiúsculas ou minúsculas. '''
    # PING
    if linha[0:4].upper() == b'PING':
        conexao.enviar(b':server PONG server :%s\r\n' % linha.split()[1])
    # NICK
    elif linha[0:4].upper() == b'NICK':
        # Atribui a variável nome ao nick enviado
        nome = linha.split(b' ',1)[1]
        # Se nome for válido
        if validar_nome(nome):
            # Verifica se o dicionário está vazio
            nome_anterior = Conexao.nicks.get(conexao)
            # Se estiver vazio atribui b'*' a variável nome_anterior
            if nome_anterior is None:
                nome_anterior = b'*'
            # Verifica se o nome já está em uso
            if nome.lower() in Conexao.nicks.values():
                conexao.enviar(b':server 433 %s %s :Nickname is already in use\r\n' % (nome_anterior, nome))
            # Se o nome não estiver em uso 
            elif nome_anterior == b'*':
                conexao.enviar(b':server 001 %s :Welcome\r\n' % nome)
                conexao.enviar(b':server 422 %s :MOTD File is missing\r\n' % nome)
                Conexao.nicks[conexao] = nome.lower()
            # Trocar nome
            else:
                Conexao.nicks[conexao] = nome.lower()
                conexao.enviar(b':%s NICK %s\r\n' % (nome_anterior, nome))
        # Se nome for inválido
        else:
            conexao.enviar(b':server 432 * %s :Erroneous nickname\r\n' % nome)
    # PRIVMSG
    elif linha[0:7].upper() == b'PRIVMSG':
        # Pegar o nome de quem envia a mensagem privada
        transmissor = Conexao.nicks[conexao].lower()
        # Pegar o nome de quem vai receber a mensagem e a mensagem
        receptor, mensagem = linha.split()[1:]
        receptor = receptor.lower()
        if receptor.startswith(b'#'):
            canal = receptor[1:]
            # Achar a conexao associada ao nome
            for conexao, nome in Conexao.canais.items():
                if nome == canal:
                    # Envia mensagem
                    conexao.enviar(b':%s PRIVMSG %s %s\r\n' % (transmissor, canal, mensagem))
            conexao.enviar(b':%s PRIVMSG %s %s\r\n' % (transmissor, canal, mensagem))
        elif receptor in Conexao.nicks.values():
            # Achar a conexao associada ao nome
            for conexao, nome in Conexao.nicks.items():
                if nome == receptor:
                    # Envia mensagem
                    conexao.enviar(b':%s PRIVMSG %s %s\r\n' % (transmissor, receptor, mensagem))
    # JOIN
    
        

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()

#!/usr/bin/env python3
import asyncio
from tcp import Servidor
from tcp import Conexao
import re

# Define o atributo global dados_residuais para a classe Conexao
Conexao.dados_residuais = b''

# Define o atributo global nicks para a classe Conexao
apelidos = {}

# Define o atributo global canais para a classe Conexao
canais = {}

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    # Concatena os dados residuais com os dados
    dados = Conexao.dados_residuais + dados
    
    # Cria uma lista para armazenar linhas terminadas em b'\r\n'
    linhas = dados.split(b'\r\n')

    # Se o último elemento da lista terminar com b'\r\n'
    if linhas[-1].endswith(b'\r\n'):
        # Caso não tenha dados residuais
        Conexao.dados_residuais = b''
    else:
        # Caso tenha dados residuais atribuí-lo a variável e removê-lo da lista
        Conexao.dados_residuais = linhas.pop(-1)

    for linha in linhas:
        #print(conexao, linha)
        processar_linha(conexao, linha)
    
def processar_linha(conexao, linha):
    # Remove espaços do começo e do final da string
    linha = linha.strip()
        
    ''' Verifica se as primeiras letras da linha é um comando
    indiferente de maiúsculas ou minúsculas. '''
    # PING
    if linha[0:4].upper() == b'PING':
        enviar_e_imprimir(conexao, b':server PONG server :%s\r\n' % linha.split()[1])
    # NICK
    elif linha[0:4].upper() == b'NICK':
        # Atribui a variável nome ao nick enviado
        nome = linha.split(b' ',1)[1]
        # Se nome for válido
        if validar_nome(nome):
            # Verifica se o dicionário está vazio
            nome_anterior = apelidos.get(conexao)
            # Se estiver vazio atribui b'*' a variável nome_anterior
            if nome_anterior is None:
                nome_anterior = b'*'
            # Verifica se o nome já está em uso
            if nome.lower() in apelidos.values():
                enviar_e_imprimir(conexao, b':server 433 %s %s :Nickname is already in use\r\n' % (nome_anterior, nome))
            # Se o nome não estiver em uso 
            elif nome_anterior == b'*':
                enviar_e_imprimir(conexao, b':server 001 %s :Welcome\r\n' % nome)
                enviar_e_imprimir(conexao, b':server 422 %s :MOTD File is missing\r\n' % nome)
                apelidos[conexao] = nome.lower()
            # Trocar nome
            else:
                apelidos[conexao] = nome.lower()
                enviar_e_imprimir(conexao, b':%s NICK %s\r\n' % (nome_anterior, nome))
        # Se nome for inválido
        else:
            enviar_e_imprimir(conexao, b':server 432 * %s :Erroneous nickname\r\n' % nome)
    # PRIVMSG
    elif linha[0:7].upper() == b'PRIVMSG':
        # Atribui o nome de quem envia a mensagem privada
        transmissor = apelidos[conexao].lower()
        # Atribui o nome de quem vai receber a mensagem e a mensagem
        receptor, mensagem = linha.split()[1:]
        receptor = receptor.lower()
        # Mensagem para um canal
        if receptor.startswith(b'#'):
            # Remove o b'#'
            canal = receptor[1:]
            # Achar a conexao associada ao nome
            for con in canais[canal]:
                print(con)
                if (con != conexao):
                    # Envia mensagem
                    enviar_e_imprimir(con, b':%s PRIVMSG #%s %s\r\n' % (transmissor, canal, mensagem))
        # Mensagem privada para usuário
        elif receptor in apelidos.values():
            # Achar a conexao associada ao nome
            for conexao, nome in apelidos.items():
                if nome == receptor:
                    # Envia mensagem
                    enviar_e_imprimir(conexao, b':%s PRIVMSG %s %s\r\n' % (transmissor, receptor, mensagem))
    # JOIN
    elif linha[0:4].upper() == b'JOIN':
        canal = linha.split()[1][1:]
        if validar_nome(canal):
            canais[canal] = {}
            canais[canal][conexao] = apelidos[conexao]
            enviar_e_imprimir(conexao, b':%s JOIN :#%s\r\n' % (apelidos[conexao], canal))
        else:
            enviar_e_imprimir(conexao, b':server 403 %s :No such channel\r\n' % canal)

def enviar_e_imprimir(conexao, dados):
    #print(dados)
    conexao.enviar(dados)
        
def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
